var documenterSearchIndex = {"docs":
[{"location":"#NDReducibles.jl-1","page":"Home","title":"NDReducibles.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"index.md\"]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [NDReducibles]\nPrivate = false","category":"page"},{"location":"#NDReducibles.ndreducible-Tuple","page":"Home","title":"NDReducibles.ndreducible","text":"ndreducible(A => (:i, :j, ...), B => (...), ..., C => (...))\n\nGiven pairs of an array (or a Broadcasted) and indices, ndreducible \"couples\" the arrays with shared index and plan the best nested for-loop along all the indices.  ndreducible returns a fold-able object which can be used with foldl and foreach defined in Transducers.jl.  Use referenceable from Referenceables.jl to mutate arrays.\n\nSee also: plan.\n\nExamples\n\nC_ij = _k A_ik B_kj + C_ij\n\njulia> using NDReducibles\n       using Referenceables: referenceable\n\njulia> A = rand(-10:10, 5, 4)\n       B = rand(-10:10, 4, 3)\n       C = zeros(Int, 5, 3);\n\njulia> foreach(\n           ndreducible(\n               referenceable(C) => (:i, :j),\n               A => (:i, :k),\n               B => (:k, :j),\n           ),\n           simd = :ivdep,  # optional\n       ) do (c, a, b)\n           c[] += a * b\n           return  # not required but useful for performance\n       end;\n\njulia> C == A * B\ntrue\n\n_i A_i B_i C_i\n\njulia> using NDReducibles\n       using Transducers: MapSplat\n\njulia> A = rand(-10:10, 5)\n       B = rand(-10:10, 5)\n       C = rand(-10:10, 5);\n\njulia> foldl(\n           +,\n           MapSplat(*),\n           ndreducible(\n               A => (:i,),\n               B => (:i,),\n               C => (:i,),\n           ),\n           simd = true,  # optional\n       ) == sum(A .* B .* C)\ntrue\n\n  A_i B_i C_i  A_i  0 \n\njulia> using NDReducibles\n       using Transducers: MapSplat, Filter\n\njulia> A = rand(-10:10, 5)\n       B = rand(-10:10, 5)\n       C = rand(-10:10, 5);\n\njulia> foldl(\n           +,\n           Filter(((a, b, c),) -> a > 0) |> MapSplat(*),\n           ndreducible(\n               A => (:i,),\n               B => (:i,),\n               C => (:i,),\n           ),\n           simd = true,  # optional\n       ) == sum(A .* (A .> 0) .* B .* C)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"internals/#Internals-1","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Modules = [NDReducibles]\nPublic = false","category":"page"},{"location":"internals/#NDReducibles.plan-Tuple{Vararg{Pair,N} where N}","page":"Internals","title":"NDReducibles.plan","text":"plan(args::AccessPattern...) :: AccessPlan\nplan(pairs::Pair...) :: AccessPlan\n\nTry to find an index that is categorized as \"fast\" for all args with such index.\n\nExamples\n\njulia> using NDReducibles: plan\n\njulia> A1 = ones(0)\n       A2 = ones(0, 0)\n       A3 = ones(0, 0, 0)\n       A4 = ones(0, 0, 0, 0);\n\njulia> plan(\n           A1 => (:i,),\n           A2 => (:i, :j),\n       )\nAccessPlan: j → i\n\njulia> plan(\n           A1 => (:i,),\n           A2 => (:j, :i),\n           A2 => (:j, :k),\n       )\nAccessPlan: i → k → j\n\njulia> plan(\n           A1 => (:i,),\n           A2' => (:j, :i),\n           A2 => (:j, :k),\n       )\nAccessPlan: j → k → i\n\njulia> plan(\n           A1 => (:i,),\n           A2' => (:i, :j),\n           A2 => (:i, :j),\n           A3 => (:k, :i, :j),\n           A4 => (:k, :j, :l, :m),\n       )\nAccessPlan: i → j → l → m → k\n\n\n\n\n\n","category":"method"}]
}
